unit CInfoApp;interface	uses		TCL, InfoIntf;implementation	const		kExtraMasters = 4;			(* number of extra master pointer blocks *)		kRainyDay = 32000;			(* total rainy day memory reserve size	 *)		kCriticalBalance = 30000;	(* portion of rainy day for critical operations *)		kToolboxBalance = 20000;	(* portion of rainy day for toolbox reserve *)	procedure ResetRandom;		var			secs: Longint;	begin		GetDateTime(secs);		RandSeed := secs;			{ Reset the global variable randSeed }	end;	function someRandom (upperBound: Integer): Integer;	begin		if upperBound > 0 then			someRandom := abs(random) mod upperBound + 1		else			someRandom := 1;	end;	function CInfoApp.GetNextRollDir: integer;	begin		GetNextRollDir := nextRollDir;	end;	procedure CInfoApp.ToggleRollDir;	begin{    if nextRollDir = kLeft then}{nextRollDir := kRight}{    else}{nextRollDir := kLeft;}		if random > 0 then			nextRollDir := kRight		else			nextRollDir := kLeft;	end;	function CInfoApp.ARandom (u: integer): integer;	begin		ARandom := someRandom(u);	end;	function CInfoApp.GetGPane: CGamePane;	begin		GetGPane := CGamePane(CInfoDir(itsDirectors.nthItem(1)).itsMainPane);	end;	function CInfoApp.GetMurphy: CMurphy;			{But that's not all...}	begin		GetMurphy := GetGPane.GetMurphy;	end;	function CInfoApp.GetMurphyObj: CMurphyObj;		{What's this?}	begin		GetMurphyObj := CMurphyObj(gos[16]);	end;	function CInfoApp.LocFromDir (x, y, d: integer): point;		var			mtx, mty: integer;	begin		case d of			kNoMove: 				begin					mtx := x;					mty := y;				end;			kUp: 				begin					mtx := x;					mty := y - 1;				end;			kRight: 				begin					mtx := x + 1;					mty := y;				end;			kDown: 				begin					mtx := x;					mty := y + 1;				end;			kLeft: 				begin					mtx := x - 1;					mty := y;				end;			kUpRight: 				begin					mtx := x + 1;					mty := y - 1;				end;			kUpLeft: 				begin					mtx := x - 1;					mty := y - 1;				end;			kDownRight: 				begin					mtx := x + 1;					mty := y + 1;				end;			kDownLeft: 				begin					mtx := x - 1;					mty := y + 1;				end;		end;		LocFromDir.h := mtx;		LocFromDir.v := mty;	end;	procedure CInfoApp.MakeGObjs;		var			c: integer;	begin		New(CPortal(gos[1]));		New(CExit(gos[2]));		New(CBug(gos[3]));		New(CTerminal(gos[4]));		New(CBlank(gos[5]));		New(CCircut(gos[6]));		New(CChip(gos[7]));		New(CHardware(gos[8]));		New(CScissor(gos[9]));		New(CQuark(gos[10]));		New(CRedDisk(gos[11]));		New(CYellowDisk(gos[12]));		New(CGreenDisk(gos[13]));		New(CZonk(gos[14]));		New(CInfotron(gos[15]));		New(CMurphyObj(gos[16]));		New(CGridPiece(gos[17]));		for c := 1 to 17 do			begin				MoveHHi(handle(gos[c]));				HLock(handle(gos[c]));				gos[c].InitPiece;			end;	end;	procedure CInfoApp.Process1Event;{HAHAHAH}{WE OVERRODE THIS}{HAHAHAHA}{DESTROYING OOP STYLE}{BREAKING INTO TCL ROUTINES}{SO THAT WE CAN DO A PROGRAM}{WHICH CLEARLY SHOULDN'T USE TCL.}{(not like we're insinuating anything.)}{That was nathan's comments.}{No it wasn't, they were davids}{be quiet brooke it was yours}{I know... blame it on the aardvarks}{No.. the platypusses!}{AARDVARKS!}{Enough!!!!!!!!!!!!!!!!!!!!!!}{(no, we're not insane.)}		var			aDAIsActive: Boolean;			minSleep: Longint;			myKeys: KeyMap;			myOldLNum: integer;			myNewLevName: str255;			ignore: boolean;			dumbrec: rect;		function ResourceName (id: integer; daKind: ResType): str255;			var				h: handle;				myId: integer;				myType: ResType;				myName: str255;		begin			ResourceName := '';			h := GetResource(daKind, id);			if h <> nil then				begin					GetResInfo(h, myId, myType, myName);					ReleaseResource(h);					ResourceName := myName;				end;		end;		procedure Chore_Perform (theChore: CChore);			var				maxSleep: Longint;		begin			maxSleep := MAXLONGINT;			theChore.Perform(maxSleep);		end;		function CanScroll (dir: integer): boolean;			var				murphy: CMurphy;				mx, my: integer;				bx, by: integer;		begin			GetMurphy.GetLoc(mx, my);			GetGPane.GetBoard.GetSize(bx, by);			if ((dir = kUp) and (my > 5) and (my < by - 5)) then				CanScroll := true			else if ((dir = kRight) and (mx < bx - 6) and (mx > 8)) then				CanScroll := true			else if ((dir = kDown) and (my > 6) and (my < by - 4)) then				CanScroll := true			else if ((dir = kLeft) and (mx > 7) and (mx < bx - 7)) then				CanScroll := true			else				canScroll := false;		end;{not that insane, at least}		procedure MurphyMove (oldX, oldY, newX, newY, myDir: integer; spaceDown: boolean);			var				xSize, ySize: integer;				what: CGridPiece;				someDum: rect;				num: integer;				count: integer;				onum: integer;{hey stop that!}		begin			lastMoved := tickCount;			isSleeping := FALSE;			if not SpaceDown then				begin					what := getGridObj(newX, newY);					num := GetGPane.GetBoard.GetData(newX, newY);					onum := GetGPane.GetBoard.GetData(oldX, oldY);					getGPane.getBoard.getSize(xSize, ySize);					getMurphy.setLastDir(myDir);					if not spaceDown then						begin							if (num >= 600) and (num <= 609) then								GetMurphyObj.Explode(newX, newY)							else if what.walkOnto(newX, newY) then								begin									GetMurphy.SetLoc(newX, newY);									if (myDir = kUp) or (myDir = kDown) then										begin											if (lastFacingLR = kLeft) then												getGPane.getBoard.setData(newX, newY, 203)											else												getGPane.getBoard.setData(newX, newY, 204);										end									else if (myDir = kLeft) then										begin											getGPane.getBoard.setData(newX, newY, 203);											lastFacingLR := kLeft;										end									else if (myDir = kRight) then										begin											getGPane.getBoard.setData(newX, newY, 204);											lastFacingLR := kRight;										end;									if ((num >= 700) and (num <= 707)) or (num = 133) or (num = 134) then										begin											if (lastFacingLR = kLeft) then												getGPane.getBoard.setData(newX, newY, 196)											else												getGPane.getBoard.setData(newX, newY, 197);											PlaySound(141);										end;									getGPane.getBoard.setData(oldX, oldY, whatToBlank);									getGPane.GetBPane.Draw1(oldX, oldY);									getGPane.GetBPane.Draw1(newX, newY);									if (num = 132) or ((num >= 900) and (num <= 952)) then										begin											whatToBlank := num;											lastWasPortal := TRUE;											getGPane.GetBoard.SetData(newX, newY, num);											getGPane.GetBPane.Draw1(newX, newY);										end									else										whatToBlank := 129;									if canScroll(myDir) then										case myDir of											kUp: 												getGPane.getBPane.moveUp;											kRight: 												getGPane.getBPane.moveRight;											kDown: 												getGPane.getBPane.moveDown;											kLeft: 												getGPane.getBPane.moveLeft;										end;									GetGPane.GetBPane.Draw(someDum);								end;						end;				end			else				begin					num := GetGPane.GetBoard.GetData(newX, newY);					if (num >= 300) and (num <= 305) then						GetMurphyObj.Explode(oldX, oldY)					else if num = 850 then						begin							case myDir of								kLeft: 									GetGPane.GetBoard.SetData(oldX, oldY, 195);								kUp: 									GetGPane.GetBoard.SetData(oldX, oldY, 199);								kRight: 									GetGPane.GetBoard.SetData(oldX, oldY, 194);								kDown: 									GetGPane.GetBoard.SetData(oldX, oldY, 200);							end;							GetGPane.GetBPane.DrawOne(oldX, oldY);							for count := 350 to 357 do								begin									GetGPane.GetBoard.SetData(newX, newY, count);									GetGPane.GetBPane.DrawOne(newX, newY);								end;							GetGPane.GetBoard.SetData(newX, newY, 129);							GetGPane.GetBPane.DrawOne(newX, newY);							GetMurphy.GotInfotron;						end					else if num = 135 then						begin							case myDir of								kLeft: 									GetGPane.GetBoard.SetData(oldX, oldY, 195);								kUp: 									GetGPane.GetBoard.SetData(oldX, oldY, 199);								kRight: 									GetGPane.GetBoard.SetData(oldX, oldY, 194);								kDown: 									GetGPane.GetBoard.SetData(oldX, oldY, 200);							end;							GetGPane.GetBPane.DrawOne(oldX, oldY);							for count := 400 to 406 do								begin									GetGPane.GetBoard.SetData(newX, newY, count);									GetGPane.GetBPane.DrawOne(newX, newY);								end;							GetGPane.GetBoard.SetData(newX, newY, 129);							GetGPane.GetBPane.DrawOne(newX, newY);							GetMurphy.GotRedDisk;						end					else if num = 128 then						begin							case myDir of								kLeft: 									GetGPane.GetBoard.SetData(oldX, oldY, 195);								kUp: 									GetGPane.GetBoard.SetData(oldX, oldY, 199);								kRight: 									GetGPane.GetBoard.SetData(oldX, oldY, 194);								kDown: 									GetGPane.GetBoard.SetData(oldX, oldY, 200);							end;							GetGPane.GetBPane.DrawOne(oldX, oldY);							for count := 450 to 456 do								begin									GetGPane.GetBoard.SetData(newX, newY, count);									GetGPane.GetBPane.DrawOne(newX, newY);								end;							GetGPane.GetBoard.SetData(newX, newY, 129);							GetGPane.GetBPane.DrawOne(newX, newY);						end;				end;			GetMurphy.LastMove := tickCount;		end;		procedure HandlePlaying;			var				count: integer;				obppassdaw: CChore;				UNINITIALIZED_SO_THERE: rect;				dumbVar: longint;				oldX, oldY, newX, newY, myDir, cx, cy: integer;				myExplChore: CExplChore;				myWaitChore: CWaitTimeChore;				myAnim: AnimArray;				mx, my: integer;				md: integer;		begin{During Play, execute ALL chores}			for count := toBeRidded.GetNumItems downto 1 do				begin																{unfortunatly, you can't assign chores from within}					obppassdaw := CChore(toBeRidded.nthItem(count));					if obppassdaw <> nil then						begin							infoUrgents.Remove(obppassdaw);							toBeRidded.remove(obppassdaw);							if CInfoChore(obppassdaw).identify = kSuicideChore then								begin									CInfoChore(obppassdaw).GetChoreLoc(cx, cy);									hasSuicide[cx, cy] := FALSE;								end;							CInfoChore(obppassdaw).GetChoreLoc(cx, cy);							if numChores^[cx, cy] > 0 then								numChores^[cx, cy] := numChores^[cx, cy] - 1;							DisposHandle(Handle(obppassdaw));							obppassdaw := nil;						end;				end;																	{chores - a loophole in TCL. Thanks to our genius,}			for count := toBeAdded.GetNumItems downto 1 do				{we were able to circumvent this problem.}				begin																	{Of course, we completly broke TCL style for it.}					obppassdaw := CChore(toBeAdded.nthItem(count));				{But hey, it was fun.}					if obppassdaw <> nil then										{...}						begin																{It was also at 3 o'clock during the night}							infoUrgents.add(obppassdaw);							toBeAdded.remove(obppassdaw);						end;				end;			for count := 1 to infoUrgents.GetNumItems do				begin					obppassdaw := CChore(infoUrgents.nthItem(count));					if obppassdaw <> nil then						obppassdaw.Perform(dumbVar);				end;			if infoUrgents.GetNumItems > 0 then				GetGPane.GetBPane.draw(UNINITIALIZED_SO_THERE);{What keys are down?}			GetKeys(myKeys);			if lastWasPortal then				begin					myKeys[91] := myOldKeys[91] or myKeys[91];					myKeys[88] := myOldKeys[88] or myKeys[88];					myKeys[84] := myOldKeys[84] or myKeys[84];					myKeys[86] := myOldKeys[86] or myKeys[86];					lastWasPortal := FALSE;				end;{Test to see if the capslock key is down}			if myKeys[57] then				begin					gameState := gameState + [isPaused];					ShowCursor;					PlaySound(sPause);				end			else if not (freezeMurphy in GameState) then				begin					if myKeys[91] then						myDir := kUp					else if myKeys[88] then						myDir := kRight					else if myKeys[84] then						myDir := kDown					else if myKeys[86] then						myDir := kLeft;					if myKeys[91] or myKeys[88] or myKeys[84] or myKeys[86] then						begin							GetMurphy.GetLoc(oldX, oldY);							newX := LocFromDir(oldX, oldY, myDir).h;							newY := LocFromDir(oldX, oldY, myDir).v;							MurphyMove(oldX, oldY, newX, newY, myDir, myKeys[49]);							spaceBarWasDown := FALSE;							diskDropSndPlayed := FALSE;						end;					if GetGPane.GetPlayer.GetName = 'Q42QaardvarkQ' then	{Majik Murphyª}						begin							if myKeys[34] then								myDir := kUp							else if myKeys[37] then								myDir := kRight							else if myKeys[46] then								myDir := kDown							else if myKeys[38] then								myDir := kLeft;							if myKeys[34] or myKeys[38] or myKeys[37] or myKeys[46] then								begin									GetMurphy.GetLoc(oldX, oldY);									newX := LocFromDir(oldX, oldY, myDir).h;									newY := LocFromDir(oldX, oldY, myDir).v;									spaceBarWasDown := FALSE;									diskDropSndPlayed := FALSE;									lastMoved := TICKCOUNT;									GetGPane.GetBoard.SetData(oldX, oldY, whatToBlank);									GetGPane.GetBPane.Draw1(oldX, oldY);									whatToBlank := GetGPane.GetBoard.GetData(newX, newY);									GetGPane.GetBoard.SetData(newX, newY, 198);									GetGPane.GetBPane.Draw1(newX, newY);									GetMurphy.SetLoc(newX, newY);									if canScroll(myDir) then										case myDir of											kUp: 												getGPane.getBPane.moveUp;											kRight: 												getGPane.getBPane.moveRight;											kDown: 												getGPane.getBPane.moveDown;											kLeft: 												getGPane.getBPane.moveLeft;										end;									GetGPane.GetBPane.Draw(UNINITIALIZED_SO_THERE);								end;						end;					if myKeys[53] then		{the esc key}						begin							GetMurphy.GetLoc(oldX, oldY);							GetMurphyObj.Explode(oldX, oldY);						end;					if (not spaceBarWasDown) and myKeys[49] then						begin		{the space bar key just went down}							whenWentDown := tickCount;							spaceBarWasDown := TRUE;		{yup, it's down.}							diskDropSndPlayed := FALSE;						end					else if spaceBarWasDown and not myKeys[49] then						begin							spaceBarWasDown := FALSE;		{not any more!}{check to see if I should drop a bomb}							if tickCount - whenWentDown > (3 * 30) then								if GetMurphy.UseRedDisk then									begin		{plant a red bomb there}										whatToBlank := 135;		{when murphy moves, show the red disk}										GetMurphy.GetLoc(oldX, oldY);										for count := 600 to 609 do											myAnim[count - 599] := count;										myAnim[11] := 129;										new(myExplChore);										myExplChore.IExplChore(oldX, oldY, myAnim, 11);										new(myWaitChore);										myWaitChore.IWaitTimeChore(myExplChore, 2);		{five cycles to LEAVE}										FudAdd(myWaitChore);									end;						end;					if myKeys[49] and spaceBarWasDown then						begin							if (tickCount - whenWentDown > (3 * 30)) and not diskDropSndPlayed then								if GetMurphy.numBombs > 0 then									begin										PlaySound(134);										diskDropSndPlayed := TRUE;									end;						end;				end;			myOldKeys := myKeys;			if not (freezeMurphy in gameState) then				if tickCount - GetMurphy.LastMove > (15) then					begin						GetMurphy.GetLoc(mx, my);						md := GetGPane.GetBoard.GetData(mx, my);						if (md <> 198) and not isSleeping then							begin								GetGPane.GetBoard.SetData(mx, my, 198);								GetGPane.GetBPane.DrawOne(mx, my);								GetMurphy.LastMove := tickCount;							end;					end;			if isSleeping then				begin					if ((sleepPhase <> 144) and (sleepPhase <> 141)) then						begin							if (scratchInteger = 0) then								begin									sleepPhase := sleepPhase + 1;									if sleepPhase > 511 then										begin											sleepPhase := 142;											scratchLongint := tickCount;											scratchInteger := 1;										end									else										begin											GetMurphy.GetLoc(mx, my);											GetGPane.GetBoard.SetData(mx, my, sleepPhase);											GetGPane.GetBPane.DrawOne(mx, my);										end;								end							else if (scratchInteger = 1) and (tickCount - scratchLongint > (2 * 60)) then								begin{    sleepPhase := sleepPhase + 1;}									if (sleepPhase = 142) and (lastFacingLR = kLeft) then										sleepPhase := 139;									GetMurphy.GetLoc(mx, my);									GetGPane.GetBoard.SetData(mx, my, sleepPhase);									GetGPane.GetBPane.DrawOne(mx, my);									scratchLongint := tickCount;									scratchInteger := 2;								end							else if (scratchInteger = 2) and (tickCount - scratchLongint > (2 * 60)) then								begin									sleepPhase := sleepPhase + 1;									GetMurphy.GetLoc(mx, my);									GetGPane.GetBoard.SetData(mx, my, sleepPhase);									GetGPane.GetBPane.DrawOne(mx, my);									scratchLongint := tickCount;									scratchInteger := 3;								end							else if (scratchInteger = 3) and (tickCount - scratchLongint > 25) then								begin									sleepPhase := sleepPhase + 1;									GetMurphy.GetLoc(mx, my);									GetGPane.GetBoard.SetData(mx, my, sleepPhase);									GetGPane.GetBPane.DrawOne(mx, my);{scratchLongint := tickCount;}{scratchInteger := 3;}								end;						end;				end			else if tickCount - lastMoved > (20 * 60) then				begin					sleepPhase := 500;					isSleeping := TRUE;					scratchInteger := 0;				end;		end;	begin		if (not (isPlaying in gameState)) or (isPaused in gameState) then			begin			(* Is a DA the front window?		*)				aDAIsActive := IsSystemWindow(WindowPeek(FrontWindow));				gDesktop.Cleanup;				itsSwitchboard.ProcessEvent;			(* A user command may have initiated a	*)			(* critical operation, e.g. Save, but	*)			(* it is complete once the event is handled*)				SetCriticalOperation(FALSE);			(* any temporary allocations should have been*)			(* released by now.*)				tempAllocation := 0;				gLastError := 0;				gLastMessage := 0;{HAHAHA WE CHANGED SOMETHING HERE HAHAHAHA}{WEEEEEEEAHHHHH!}				if (urgentsToDo) then					begin				(* Carry out urgent chores			*)						itsUrgentChores.DoForEach(Chore_Perform);						itsUrgentChores.DisposeItems;						urgentsToDo := FALSE;					end;		(* Check for context-switch with	*)		(*   Desk Accessories				*)				if (IsSystemWindow(WindowPeek(FrontWindow))) then					begin						gSleepTime := 0;						if (not aDAIsActive) then							begin								aDAIsActive := TRUE;								SwitchToDA;							end;					end				else					begin						if (aDAIsActive) then							begin								aDAIsActive := FALSE;								SwitchFromDA;							end;					end;				ForceNextPrepare;				ForgetObject(unhandledTask);				if isPaused in gameState then					begin						GetKeys(myKeys);						if not myKeys[57] then {no caps lock}							begin								gameState := gameState - [isPaused];								HideCursor;								PlaySound(sUnpause);							end;					end;				if not (isPaused in gameState) then					if loadNextLevel then			{the next level needs to be loaded into memory}						begin							loadNextLevel := FALSE;							myOldLNum := GetGPane.GetPlayer.GetLevelNum;							myNewLevName := ResourceName(myOldLNum + 301, levelResType);							GetGPane.GetPlayer.SetLevelNum(myOldLNum + 1);							GetGPane.GetPlayer.SetLevelName(myNewLevName);							ignore := GetGPane.GetBoard.LoadBoard(myNewLevName);							if myOldLNum in GetGPane.GetPlayer.SkippedLev then								begin									GetGPane.GetPlayer.SkippedLev := GetGPane.GetPLayer.SkippedLev - [myOldLNum];									GetGPane.GetPlayer.numSkipped := GetGPane.GetPlayer.numSkipped - 1;								end;							if GetGPane.GetPlayer.highLev = myOldLNum then								GetGPane.GetPlayer.highLev := GetGPane.GetPlayer.highLev + 1;							GetGPane.GetPlayer.current := myOldLNum + 1;							GetGPane.GetPlayer.SavePlayer;							GetGPane.GetBPane.GotNewBoard;						end;			end		else			HandlePlaying;{check to see if we should flush our chore list...}		if shouldKillChores then			DoKillChores;	end;	procedure Calculate_Meaning_Of_Life (earth: integer);	begin		Calculate_Meaning_Of_Life(42);	{this may take a while, but we'll get there eventually}	end;	procedure CInfoApp.Idle (macEvent: EventRecord); (* Usually a null or system event	*)		var			count: integer;			obppassdaw: CChore;			UNINITIALIZED_SO_THERE: rect;	begin		inherited Idle(macEvent);	end;	procedure CInfoApp.FudADD (chore: CChore);		{add some chores here}		var			cx, cy: integer;	begin		if chore <> nil then			begin				if CInfoChore(chore).Identify = kSuicideChore then					begin						CInfoChore(chore).GetChoreLoc(cx, cy);						if not hasSuicide[cx, cy] then							begin								hasSuicide[cx, cy] := TRUE;								numChores^[cx, cy] := numChores^[cx, cy] + 1;								toBeAdded.add(chore);							end;					end				else					begin						CInfoChore(chore).GetChoreLoc(cx, cy);						numChores^[cx, cy] := numChores^[cx, cy] + 1;						toBeAdded.add(chore);					end;			end;	end;	procedure CInfoApp.FudRID (chore: CChore);		{rid some chores here}		var			cx, cy: integer;	begin		if chore <> nil then			toBeRidded.add(chore);	end;	function CInfoApp.GetGridObj (x, y: integer): CGridPiece;		var			what: integer;			mo: CGridPiece;	begin		what := self.GetGPane.GetBoard.GetData(x, y);		mo := gos[17];		if what = 128 then			mo := gos[grCircut]		else if what = 129 then			mo := gos[grBlank]		else if ((what >= 850) and (what <= 853)) or ((what >= 350) and (what <= 358)) then			mo := gos[grInfotron]		else if (what >= 700) and (what <= 707) then			mo := gos[grZonk]		else if (what = 131) or ((what >= 1100) and (what <= 1106)) then			mo := gos[grChip]		else if ((what >= 750) and (what <= 757)) or ((what >= 1050) and (what <= 1057)) then			mo := gos[grHardware]		else if (((what >= 998) and (what <= 1009)) or ((what >= 1148) and (what <= 1160))) then			mo := gos[grScissor]		else if (what >= 650) and (what <= 666) then	{santa}			mo := gos[grQuark]		else if (what >= 300) and (What <= 304) then			mo := gos[grBug]		else if (what = 132) or ((what >= 900) and (what <= 952)) then			mo := gos[grPortal]		else if what = 133 then			mo := gos[grGreen]		else if what = 135 then			mo := gos[grRed]		else if what = 134 then			mo := gos[grYellow]		else if (what >= 550) and (what <= 561) then			mo := gos[grTerminal]		else if what = 130 then			mo := gos[grExit]		else if ((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210)) then			mo := gos[grMurphyObj];		GetGridObj := mo;	end;	procedure CInfoApp.DoKillChores;	{actually kill the chores. NEVER call this!!!}		var									{Because you might be doing so from WITHIN a chore!!!!}			myObj: CObject;			count: integer;	begin		ClearSuicides;		for count := infoUrgents.GetNumItems downto 1 do			begin				myObj := infoUrgents.nthItem(count);				infoUrgents.remove(myObj);				if myObj <> nil then					begin{    CInfoChore(myObj).FreeMemory;}						DisposeHandle(handle(myObj));					end;			end;		for count := toBeAdded.GetNumItems downto 1 do			begin				myObj := toBeAdded.nthItem(count);				toBeAdded.remove(myObj);				if myObj <> nil then					begin{CInfoChore(myObj).FreeMemory;}						DisposeHandle(handle(myObj));					end;			end;		for count := toBeRidded.GetNumItems downto 1 do			begin				myObj := toBeRidded.nthItem(count);				toBeRidded.remove(myObj);				if myObj <> nil then					begin{CInfoChore(myObj).FreeMemory;}						DisposeHandle(handle(myObj));					end;			end;		shouldKillChores := FALSE;	end;	procedure CInfoApp.KillChores;			{Set up BOOLEAN to kill chores. DON'T ACTUALLY KILL THEM}		var										{Because this may be called from WITHIN a chore!!!!}			myObj: CObject;			count: integer;	begin		shouldKillChores := TRUE;	end;	procedure CInfoApp.SetInfoStatus (gs: InfoStatus);	begin		gameState := gs;	end;	function CInfoApp.GetInfoStatus: InfoStatus;	begin		GetInfoStatus := gameState;	end;	procedure CInfoApp.CreateCGameDirector;		var			myInfoDir: CInfoDir;	begin		new(myInfoDir);		myInfoDir.IInfoDir(self);	end;	procedure CInfoApp.IInfoApp;		var			oe: OSErr;			at: point;			stop: longint;			continue: boolean;			tempRect: rect;			gMainWind: WindowPtr;			randomRect: rect;			tAboutDial, tNewDial, tRenDial, tKeysDial, tHelpDial: CInfoDialog;			tLevelDial, tOpenDial, tDeleteDial: CInfoScrollDialog;			myNC: NCPtr;		function showLogo (pic: integer): boolean;			var				stop: longint;		begin			FillRect(gMainWind^.portRect, black);			DrawPicCenterGraf(pic);			FadeFromBlack(2);			stop := tickCount + 180;			while not button and (tickCount < stop) do				;			showLogo := button;			FadeToBlack(2);			FillRect(gMainWind^.portRect, black);		end;	begin		SoundsInit(TRUE);		SoundState(TRUE);		myNC := NCPtr(NewPtrClear(sizeOf(NCArray)));		numChores := myNC;		InitMenuBars;		oe := SetupGammaTools;		nextRollDir := kRight;		FadeToBlack(2);		HideCursor;		gMainWind := NewCWindow(nil, screenBits.bounds, '', TRUE, 2, WindowPtr(-1), false, 0);		ShowWindow(gMainWind);		SetPort(gMainWind);		HideMenuBar(gMainWind);		RGBForeColor(myBlackColor);		continue := ShowLogo(147);		SetPort(gMainWind);		makeGObjs;		shouldKillChores := FALSE;		if not continue then			continue := ShowLogo(148);		ShowMenuBar(gMainWind);		DisposeWindow(gMainWind);		New(toBeAdded);		New(toBeRidded);		New(infoUrgents);		toBeAdded.IList;		toBeRidded.IList;		infoUrgents.IList;		IApplication(kExtraMasters, kRainyDay, kCriticalBalance, kToolboxBalance);		ResetRandom;		CreateCGameDirector;		gBartender.checkMarkCmd(iCmdSoundFX, true);		setUpDials(tAboutDial, tNewDial, tRenDial, tKeysDial, tHelpDial, tLevelDial, tOpenDial, tDeleteDial);		gAboutDial := tAboutDial;		gNewDial := tNewDial;		gRenDial := tRenDial;		gKeysDial := tKeysDial;		gHelpDial := tHelpDial;		gLevelDial := tLevelDial;		gOpenDial := tOpenDial;		gDeleteDial := tDeleteDial;		loadNextLevel := FALSE;		SetInfoStatus([fadeFromB, hasSound]);	end;	procedure CInfoApp.SetUpFileParameters;	begin		inherited SetUpFileParameters;		sfNumTypes := 1;		sfFileTypes[0] := 'TEXT';		gSignature := 'MŸrf';	end;	procedure CInfoApp.SetUpMenus;	begin		inherited SetUpMenus;	end;	procedure CInfoApp.NewPlayer;		var			aName: str255;			ignore: boolean;			thePlayer: CPlayer;	begin		if GetWinName(aName, gNewDial) then			begin				thePlayer := GetGPane.GetPlayer;				thePlayer.INewPlayer(aName);				thePlayer.savePlayer;				if aName = 'Q42QaardvarkQ' then					begin						thePlayer.highLev := Count1Resources(levelResType);						thePlayer.savePlayer;					end;				ignore := getGPane.getBoard.loadBoard(thePlayer.GetLevelName);				GetGPane.GetBPane.GotNewBoard;				gameState := gameState + [hasPlayer];			end;	end;	procedure CInfoApp.DoCommand (theCommand: longint);		var			data: handle;			tempData: handle;			c, x: integer;			name: Str255;			sounds: boolean;	begin		case theCommand of			iCmdNew: 				begin					KillChores;					newPlayer;				end;			iCmdOpen: 				begin					KillChores;					GetGPane.GetPlayer.OpenPlayer;				end;			iCmdRename: 				GetGPane.GetPlayer.RenamePlayer;			iCmdDelete: 				if DeleteChoice(name, gDeleteDial) then					begin						if name <> GetGPane.GetPlayer.GetName then							begin								tempData := GetNamedResource(playerResType, name);								if (tempData <> nil) and (resError = noErr) then									begin										RmveResource(tempData);										ReleaseResource(tempData);									end;							end						else							DoError('This game does not condone suicide.  Please call Dr. Jack Kevorkian.');					end;			iCmdLevel: 				begin					KillChores;					GetGPane.GetPlayer.ChooseLevel;				end;			iCmdHelp: 				doHelp(gHelpDial);			iCmdStart: 				begin					if isPlaying in gameState then						begin							gameState := gameState - [isPlaying];							gameState := gameState - [isPaused];							gBartender.SetCmdText(iCmdStart, 'Start');							DoKillChores;		{get rid of the chores}						end					else						begin							gameState := gameState + [isPlaying];							gBartender.setCmdText(iCmdStart, 'Abort');							getGPane.startNewLevel;						end;				end;			iCmdSoundFX: 				begin					sounds := hasSound in gameState;					gBartender.checkMarkCmd(iCmdSoundFX, not sounds);					if sounds then						gameState := gameState - [hasSound]					else						gameState := gameState + [hasSound];					SoundState(not sounds);				end;			cmdAbout: 				begin					PlaySound(sAboutBox);					doAbout(gAboutDial);				end;			cmdQuit: 				begin					ExitApp;					ExitToShell;				end;			otherwise				inherited DoCommand(theCommand);		end;	end;	procedure CInfoApp.UpdateMenus;	begin		inherited UpdateMenus;		gBartender.EnableCmd(iCmdHelp);		gBartender.EnableCmd(iCmdDelete);		gBartender.EnableCmd(iCmdQuit);		gBartender.EnableCmd(iCmdSoundFX);		gBartender.checkMarkCmd(iCmdSoundFX, hasSound in gameState);		if not (isPaused in GameState) then			begin				gBartender.EnableCmd(iCmdNew);				gBartender.EnableCmd(iCmdOpen);			end;		if hasPlayer in GameState then			begin				gBartender.EnableCmd(iCmdRename);				if not (isPaused in GameState) then					gBartender.EnableCmd(iCmdLevel);				if (hasLevel in GameState) and not loadNextLevel then					gBartender.EnableCmd(iCmdStart);				if isPlaying in GameState then					gBartender.SetCmdText(iCmdStart, 'Abort')				else					gBartender.SetCmdText(iCmdStart, 'Start');			end;	end;	procedure CInfoApp.ExitApp;		var			oe: OSErr;	begin		DoKillChores;		oe := DisposeGammaTools;		SoundsClose;		if numChores <> nil then			DisposePtr(ptr(numChores));	end;	function CInfoApp.Quit: Boolean;	begin{This is a REALLY BAD WAY to quit.}{But we're bad. So there}		SoundsClose;		ExitToShell;	end;	procedure CInfoApp.TheyWonTheLevel;	begin		loadNextLevel := TRUE;	end;	procedure CInfoApp.ClearSuicides;		var			x, y: integer;			xs, ys: integer;	begin		if hasLevel in gameState then			GetGPane.GetBoard.GetSize(xs, ys)		else			begin				xs := 120;				ys := 120;			end;		for x := 1 to xs do			for y := 1 to xs do				begin					hasSuicide[x, y] := FALSE;					numChores^[x, y] := 0;				end;		spaceBarWasDown := FALSE;		whatToBlank := 129;		diskDropSndPlayed := false;		lastWasPortal := FALSE;		lastFacingLR := kRight;		isSleeping := FALSE;		lastMoved := tickCount;	end;	procedure CInfoApp.CreateDocument;		var			theDocument: CInfoDir;			fi: FailInfo;		procedure HandleFailure (error: Integer; message: Longint);		begin			ForgetObject(theDocument);		end;	begin	end;	procedure CInfoApp.OpenDocument (macSFReply: SFReply);	begin	end;end.