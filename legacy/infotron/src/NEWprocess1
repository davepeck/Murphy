procedure Process1Event;	function ResourceName (id: integer; daKind: ResType): str255;		var			h: handle;			myId: integer;			myType: ResType;			myName: str255;	begin		ResourceName := '';		h := GetResource(daKind, id);		if h <> nil then			begin				GetResInfo(h, myId, myType, myName);				ReleaseResource(h);				ResourceName := myName;			end;	end; {ResourceName}	function CanScroll (dir: integer): boolean;		var			mx, my: integer;			bx, by: integer;	begin		GetLoc(mx, my);		GetSize(bx, by);		if ((dir = kUp) and (my > 7) and (my < by - 6)) then					{7,6}			CanScroll := true		else if ((dir = kRight) and (mx < bx - 9) and (mx > 11)) then		{9,11}			CanScroll := true		else if ((dir = kDown) and (my > 8) and (my < by - 5)) then		{8,5}			CanScroll := true		else if ((dir = kLeft) and (mx > 10) and (mx < bx - 10)) then		{10,10}			CanScroll := true		else			canScroll := false;	end;		{CanScroll}	procedure SmoothMusic;		var			nmid: integer;	begin		if (hasMusic in gameState) then			if ((tickCount - lastMusicChange) > (kSecondsForMusic * 60)) or (musicRefNum = -1) then				begin					nmid := ARandom(3) + 999;					if (musicRefNum = -1) then						begin							musicID := nmid;							musicRefNum := ContSound(musicID);						end					else if nmid <> musicID then						begin							ContSoundStop(musicRefNum);							musicID := nmid;							musicRefNum := ContSound(musicID);						end;					lastMusicChange := tickCount;				end;	end;		{SmoothMusic}	procedure CoolPortals (oldX, oldY, newX, newY, myDir, num: integer);		var			murphPic, offX, offY, offX2, offY2, realNewX, realNewY: integer;	begin		whatToBlank := num;		lastWasPortal := TRUE;		myGoUp := myKeys[gUpKey];		myGoDown := myKeys[gDownKey];		myGoLeft := myKeys[gLeftKey];		myGoRight := myKeys[gRightKey];		murphPic := GetData(newX, newY);		realNewX := LocFromDir(newX, newY, myDir).h;		realNewY := LocFromDir(newX, newY, myDir).v;		case myDir of			kUp: 				begin					offX := 0;					offX2 := 0;					offY := -16;					offY2 := 16;				end;			kDown: 				begin					offX := 0;					offX2 := 0;					offY := 16;					offY2 := -16;				end;			kLeft: 				begin					offX := -16;					offX2 := 16;					offY := 0;					offY2 := 0;				end;			kRight: 				begin					offX := 16;					offX2 := -16;					offY := 0;					offY2 := 0;				end;		end;		SetData(newX, newY, num);		DrawOffset(oldX, oldY, offX, offY, murphPic);		DrawOffset(realNewX, realNewY, offX2, offY2, murphPic);		Draw1(newX, newY);	end;		{CoolPortals}	procedure MurphyMove (oldX, oldY, newX, newY, myDir: integer; spaceDown: boolean);		const			kExplStart = 600;			kExplEnd = 609;			kInfoStart = 350;			kInfoEnd = 358;			kBoldStart = 700;			kBoldEnd = 707;			kGreen = 133;			kYellow = 134;			kRed = 135;			k4Way = 132;			kPortStart = 900;			kPortEnd = 952;			kBugStart = 300;			kBugEnd = 305;			kTheInfo = 850;			kRedStart = 400;			kRedEnd = 406;			kCirc = 128;			kCircStart = 450;			kCircEnd = 456;		var			what: CGridPiece;			num, onum, count: integer;			xSize, ySize: integer;			count: integer;	begin		lastMove := tickCount;		isSleeping := FALSE;	{damn it!}		if not spaceDown then			begin				what := GetGridObj(newX, newY);				num := GetData(newX, newY);				onum := GetData(oldX, oldY);				GetSize(xSize, ySize);				SetLastDir(myDir);				if ((num >= kExplStart) & (num <= kExplEnd)) | ((num >= kInfoStart) & (num <= kInfoEnd)) then					GetMurphyObj.killMurphy		{used to be explode(newX,newY)}				else if (what.WalkOnto(newX, newY)) then					if not gAARDVARK_PLATYPUSS_WOMBAT then						begin	{ok, murphy can move}							SetLoc(newX, newY);	{set his location}							if (myDir = kUp) or (myDir = kDown) then	{and his data}								begin									if lastFacingLR = kLeft then										SetData(newX, newY, kBase + kLft + gPhase)									else										SetData(newX, newY, kBase + kRt + gPhase);								end	{up or down}							else if (myDir = kLeft) then								begin									SetData(newX, newY, kBase + kLft + gPhase);									lastFacingLR := kLeft;								end	{left}							else if (myDir = kRight) then								begin									SetData(newX, newY, kBase + kRt + gPhase);									lastFacingLR := kRight;								end;	{right}							if (gPhase = kSmall) or (gPhase = kBig) then	{change his chomp}								gPhase := kMed							else								begin									gPhase := gFromMed;									gFromMed := 4 - gFromMed;								end;	{gPhase is kMed}							if ((num >= kBoldStart) and (num <= kBoldEnd)) or (num = kGreen) or (num = kYellow) then								begin									if lastFacingLR = kLeft then										SetData(newX, newY, 196)									else										SetData(newX, newY, 197);									PlaySound(141);	{the pushing noise}								end;		{pushing nums}							SetData(oldX, oldY, whatToBlank);							Draw1(oldX, oldY);							Draw1(newX, newY);							if (num = k4Way) or ((num >= kPortStart) and (num <= kPortEnd)) then								CoolPortals(oldX, oldY, newX, newY, myDir, num)							else								whatToBlank := 129;							if CanScroll(myDir) then								case myDir of									kUp: 										MoveUp;									kLeft: 										MoveLeft;									kRight: 										MoveRight;									kDown: 										MoveDown;								end	{case myDir}							else	{can't scroll (myDir)}								RedrawBoard;						end;	{not gAARDVARK_P_W}			end {if not spaceDown}		else		{woops space is down}			begin				num := GetData(newX, newY);				if (num >= kBugStart) and (num <= kBugEnd) then					GetMurphyObj.ExplodeTWO(oldX, oldY)				else if (num = kTheInfo) or (num = kRed) or (num = kCirc) then					begin						case myDir of							kLeft: 								SetData(oldX, oldY, 195);							kUp: 								SetData(oldX, oldY, 199);							kRight: 								SetData(oldX, oldY, 194);							kDown: 								SetData(oldX, oldY, 200);						end;	{case myDir of}						DrawOne(oldX, oldY);						if (num = kTheInfo) then							begin								for count := kInfoStart to kInfoEnd - 1 do									begin										SetData(newX, newY, count);										DrawOne(newX, newY);									end;	{for count}								GotInfotron;							end {it is an infotron}						else if (num = kRed) then {it is a red disk}							begin								for count := kRedStart to kRedEnd do									begin										SetData(newX, newY, count);										DrawOne(newX, newY);									end;	{for count}								GotRedDisk;							end						else	{it is a circuit}							for count := kCircStart to kCircEnd do								begin									SetData(newX, newY, count);									DrawOne(newX, newY);								end;	{for count}						SetData(newX, newY, 129);						DrawOne(newX, newY);					end;	{num=kTheInfo or num=kRed or num=kCirc}			end;		{end space is down}		gMurphy.lastMove := tickCount;	end;	procedure HandlePlaying;		const			kPauseKey = 57;			kMUp = 34;			kMLeft = 38;			kMRight = 37;			kMDown = 46;			kSuicideKey = 53;		var			startTick, endTick: longint;			myKeys: keyMap;		procedure DoAllChores;			var				count: integer;				listInd: integer;		begin			for count := 1 to tbrLen do				if toBeRidded[count] <> nil then					begin						listInd := toBeRidded[count].listindex;						infoUrgents[listind] := infoUrgents[iuLen];						infoUrgents[listind].listindex := listind;						iuLen := iuLen - 1;						DisposeHandle(Handle(toBeRidded[count]));						toBeRidded[count] := nil;					end;			tbrLen := 0;			for count := 1 to tbaLen do				if toBeAdded[count] <> nil then					begin						iuLen := iuLen + 1;						infoUrgents[iuLen] := toBeAdded[count];						infoUrgents[iuLen].listindex := iuLen;						toBeAdded[count] := nil;					end;			tbaLen := 0;			for count := 1 to iuLen do				if infoUrgents[count] <> nil then					infoUrgents[count].perform(dorkl);			if iulen > 0 then				RedrawBoard;		end;		procedure DoPause;		begin			gameState := gameState + [isPaused];			ShowCursor;			ContSoundStop(musicRefNum);			musicRefNum := -1;			HaltSounds;			PlaySound(sPause);			StopTime;			ShowMenuBar(gMainWind);		end;		procedure DoLastWasPortal;			var				oldX, oldY: integer;		begin			myKeys[gUpKey] := myGoUp;			myKeys[gRightKey] := myGoRight;			myKeys[gLeftKey] := myGoLeft;			myKeys[gDownKey] := myGoDown;			GetLoc(oldX, oldY);			Draw1(oldX - 1, oldY);			Draw1(oldX + 1, oldY);			Draw1(oldX, oldY - 1);			Draw1(oldX, oldY + 1);			lastWasPortal := FALSE;		end;		procedure PrepareMove (u, r, d, l, s: boolean);			var				oldX, oldY, newX, newY, myDir: integer;		begin			if u then				myDir := kUp			else if r then				myDir := kRight			else if d then				myDir := kDown			else if l then				myDir := kLeft;			if u | r | d | l | s then				begin					GetLoc(oldX, oldY);					newX := LocFromDir(oldX, oldY, myDir).h;					newY := LocFromDir(oldX, oldY, myDir).v;					MurphyMove(oldX, oldY, newX, newY, myDir, s);					spaceBarWasDown := FALSE;					diskDropSndPlayed := FALSE;				end;		end;		procedure MajikMurphy (u, l, r, d: boolean);			var				oldX, oldY, newX, newY: integer;				myDir: integer;		begin			if u then				myDir := kUp			else if r then				myDir := kRight			else if d then				myDir := kDown			else if l then				myDir := kLeft;			if u | r | d | l then				begin					GetLoc(oldX, oldY);					newX := LocFromDir(oldX, oldY, myDir).h;					newY := LocFromDir(oldX, oldY, myDir).v;					spaceBarWasDown := FALSE;					diskDropSndPlayed := FALSE;					lastMoved := TICKCOUNT;					SetData(oldX, oldY, whatToBlank);					Draw1(oldX, oldY);					whatToBlank := GetData(newX, newY);					SetData(newX, newY, 198);					Draw1(newX, newY);					SetLoc(newX, newY);					if canScroll(myDir) then						case myDir of							kUp: 								moveUp;							kRight: 								moveRight;							kDown: 								moveDown;							kLeft: 								moveLeft;						end					else						RedrawBoard;				end;		end;		procedure SpaceBarDown;		begin			whenWentDown := tickCount;			spaceBarWasDown := TRUE;			diskDropSndPlayed := FALSE;		end;		procedure NoLongerDown;			var				oldX, oldY, count: integer;				myAnim: AnimArray;				myExplChore: CExplChore;				myWaitChore: CWaitTimeChore;		begin			spaceBarWasDown := FALSE;			if tickCount - whenWentDown > 90 then				if UseRedDisk then					begin						whatToBlank := 1105;						GetLoc(oldX, oldY);						for count := 600 to 609 do							myAnim[count - 599] := count;						myAnim[11] := 129;						New(myExplChore);						myExplChore.IExplChore(oldX, oldY, myAnim, 11);						new(myWaitChore);						myWaitChore.IWaitTimeChore(myExplChore, 2);						FudAdd(myWaitChore);					end;		end;		procedure SpaceBarStillDown;		begin			if (tickCount - whenWentDown > 90) and not diskDropSndPlayed then				if gMurphy.NumBombs > 0 then					begin						PlaySound(134);						diskDropSndPlayed := TRUE;					end;		end;		procedure NormalMurphy;			var				mx, my, md: integer;		begin			GetLoc(mx, my);			md := GetData(mx, my);			if (md <> 198) and not isSleeping then				begin					SetData(mx, my, 198);					DrawOne(mx, my);					gMurphy.LastMove := tickCount;					gPhase := kMed;					gFromMed := kBig;				end;		end;		procedure DoSleepStuff;			var				mx, my: integer;		begin			if (sleepPhase <> 144) and (sleepPhase <> 141) then				begin					if (scratchInteger < 3) and (tickCount - scratchLongint > (5 * 60)) then {still on yawning}						begin							sleepPhase := sleepPhase + 1;							scratchLongint := 0;							if sleepPhase > 511 then	{finished a yawn}								begin									sleepPhase := 499;									scratchLongint := tickCount;									scratchInteger := scratchInteger + 1;								end	{sleepPhase>511}							else								begin									GetLoc(mx, my);									SetData(mx, my, sleepPhase);									DrawOne(mx, my);								end;		{sleepPhase<=511}						end {scratchInt<3}					else if (scratchInteger = 3) and (tickCount - scratchLongint > (2 * 60)) then	{gets mad}						begin							if lastFacingLR = kLeft then								sleepPhase := 139							else								sleepPhase := 142;							GetLoc(mx, my);							SetData(mx, my, sleepPhase);							DrawOne(mx, my);							scratchLongint := tickCount;							scratchInteger := 4;						end	{scratchInt=3}					else if (scratchInteger = 4) and (tickCount - scratchLongint > (4 * 60)) then	{gets idea}						begin							sleepPhase := sleepPhase + 1;							GetLoc(mx, my);							SetData(mx, my, sleepPhase);							DrawOne(mx, my);							scratchLongint := tickCount;							scratchInteger := 5;						end					else if (scratchInteger = 5) and (tickCount - scratchLongint > (2 * 60)) then {falls asleep}						begin							sleepPhase := sleepPhase + 1;							GetLoc(mx, my);							SetData(mx, my, sleepPhase);							DrawOne(mx, my);							scratchInteger := 6;						end;				end;		{not 144 or 141}		end;		procedure StartSleep;		begin			sleepPhase := 500;			isSleeping := TRUE;			scratchInteger := 0;			scratchLongint := 0;		end;	begin		startTick := tickCount;		DoAllChores;		GetKeys(myKeys);		if (myKeys[kPauseKey] = pauseKeyState) then			DoPause		else	{i'm not paused}			begin				if lastWasPortal then					DoLastWasPortal;				PrepareMove(myKeys[gUpKey], myKeys[gRightKey], myKeys[gDownKey], myKeys[gLeftKey], myKeys[gSpecKey]);				if GetName = 'Q42QaardvarkQ' then {Majik Murphyª}					MajikMurphy(myKeys[kMUp], myKeys[kMLeft], myKeys[kMRight], myKeys[kMDown]);				if myKeys[kSuicideKey] then					GetMurphyObj.KillMurphy;		{might be Explode(mx,my)}				if (not spaceBarWasDown) and myKeys[gSpecKey] then					SpaceBarDown	{the space bar (or special key) went down.}				else if (spaceBarWasDown) and (not myKeys[gSpecKey]) then					NoLongerDown; {the space bar (or special key) is no longer down.}				if spaceBarWasDown and myKeys[gSpecKey] then					SpaceBarStillDown;				if (tickCount - gMurphy.LastMove) > 15 then					NormalMurphy;				if isSleeping then					DoSleepStuff				else if (tickCount - lastMoved) > (30 * 60) then					StartSleep;			end;		{not (myKeys[kPauseKey]=pauseKeyState)}		endTick := tickCount;		if (endTick - startTick) < kTicksBetween then			while (tickCount - startTick) < kTicksBetween do				;	end;begin		{Process1Event}	HandlePlaying;	SmoothMusic;	if shouldKillChores then		begin			DoKillChores;			ShowMenuBar(gMainWind);			ContSoundStop(musicRefNum);			musicRefNum := -1;			HaltSounds;		end;	DrawTBoxes(FALSE);end;