procedure Process1Event;{HAHAHAH}{WE OVERRODE THIS}{HAHAHAHA}{DESTROYING OOP STYLE}{BREAKING INTO TCL ROUTINES}{SO THAT WE CAN DO A PROGRAM}{WHICH CLEARLY SHOULDN'T USE TCL.}{(not like we're insinuating anything.)}{That was nathan's comments.}{No it wasn't, they were davids}{be quiet brooke it was yours}{I know... blame it on the aardvarks}{No.. the platypusses!}{AARDVARKS!}{Enough!!!!!!!!!!!!!!!!!!!!!!}{(no, we're not insane.)}	var		aDAIsActive: Boolean;		minSleep: Longint;		myKeys: KeyMap;		myOldLNum: integer;		myNewLevName: str255;		ignore: boolean;		dumbrec: rect;	function ResourceName (id: integer; daKind: ResType): str255;		var			h: handle;			myId: integer;			myType: ResType;			myName: str255;	begin		ResourceName := '';		h := GetResource(daKind, id);		if h <> nil then			begin				GetResInfo(h, myId, myType, myName);				ReleaseResource(h);				ResourceName := myName;			end;	end;	function CanScroll (dir: integer): boolean;		var			mx, my: integer;			bx, by: integer;	begin		GetLoc(mx, my);		GetSize(bx, by);		if ((dir = kUp) and (my > 7) and (my < by - 6)) then					{7,6}			CanScroll := true		else if ((dir = kRight) and (mx < bx - 9) and (mx > 11)) then		{9,11}			CanScroll := true		else if ((dir = kDown) and (my > 8) and (my < by - 5)) then		{8,5}			CanScroll := true		else if ((dir = kLeft) and (mx > 10) and (mx < bx - 10)) then		{10,10}			CanScroll := true		else			canScroll := false;	end;	procedure SmoothMusic;		var			nmid: integer;	begin		if (hasMusic in gameState) then			if ((tickCount - lastMusicChange) > (kSecondsForMusic * 60)) or (musicRefNum = -1) then				begin					nmid := ARandom(3) + 999;					if (musicRefNum = -1) then						begin							musicID := nmid;							musicRefNum := ContSound(musicID);						end					else if nmid <> musicID then						begin							ContSoundStop(musicRefNum);							musicID := nmid;							musicRefNum := ContSound(musicID);						end;					lastMusicChange := tickCount;				end;{Do da musak junx}{    if (hasMusic in gameState) then}{    if not ChanUsed(1) then}{    begin}{    repeatCnt := repeatCnt + 1;}{    if repeatCnt > 4 then}{    begin}{    musicId := ARandom(3) + 999;}{    repeatCnt := 1;}{    end;}{    PlaySound(musicID);}{    end;}	end;	procedure CoolPortals (oldX, oldY, newX, newY, myDir, num: integer);		var			murphPic, offX, offY, offX2, offY2, realNewX, realNewY: integer;	begin		whatToBlank := num;		lastWasPortal := TRUE;		myGoUp := myKeys[gUpKey];		myGoDown := myKeys[gDownKey];		myGoLeft := myKeys[gLeftKey];		myGoRight := myKeys[gRightKey];		murphPic := GetData(newX, newY);		realNewX := LocFromDir(newX, newY, myDir).h;		realNewY := LocFromDir(newX, newY, myDir).v;		case myDir of			kUp: 				begin					offX := 0;					offX2 := 0;					offY := -16;					offY2 := 16;				end;			kDown: 				begin					offX := 0;					offX2 := 0;					offY := 16;					offY2 := -16;				end;			kLeft: 				begin					offX := -16;					offX2 := 16;					offY := 0;					offY2 := 0;				end;			kRight: 				begin					offX := 16;					offX2 := -16;					offY := 0;					offY2 := 0;				end;		end;		SetData(newX, newY, num);		DrawOffset(oldX, oldY, offX, offY, murphPic);		DrawOffset(realNewX, realNewY, offX2, offY2, murphPic);		Draw1(newX, newY);	end;{not that insane, at least}	procedure MurphyMove (oldX, oldY, newX, newY, myDir: integer; spaceDown: boolean);		var			xSize, ySize: integer;			what: CGridPiece;			someDum: rect;			num: integer;			count: integer;			onum: integer;{hey stop that!}	begin		lastMoved := tickCount;		isSleeping := FALSE;		if not SpaceDown then			begin				what := getGridObj(newX, newY);				num := GetData(newX, newY);				onum := GetData(oldX, oldY);				getSize(xSize, ySize);				setLastDir(myDir);				if not spaceDown then					begin						if ((num >= 600) and (num <= 609)) | ((num >= 350) and (num <= 358)) then							GetMurphyObj.Explode(newX, newY)						else if what.walkOnto(newX, newY) then							begin								if not gAARDVARK_PLATYPUSS_WOMBAT then									begin										SetLoc(newX, newY);{    if num = 128 then}{    PlaySound(142);}										if (myDir = kUp) or (myDir = kDown) then											begin												if (lastFacingLR = kLeft) then													setData(newX, newY, kBase + kLft + gPhase)												else													setData(newX, newY, kBase + kRt + gPhase);											end										else if (myDir = kLeft) then											begin												setData(newX, newY, kBase + kLft + gPhase);												lastFacingLR := kLeft;											end										else if (myDir = kRight) then											begin												setData(newX, newY, kBase + kRt + gPhase);												lastFacingLR := kRight;											end;										if (gPhase = kSml) then											gPhase := kMed										else if (gPhase = kBig) then											gPhase := kMed										else											begin												gPhase := gFromMed;												gFromMed := 4 - gFromMed;											end;										if ((num >= 700) and (num <= 707)) or (num = 133) or (num = 134) then											begin												if (lastFacingLR = kLeft) then													setData(newX, newY, 196)												else													setData(newX, newY, 197);												PlaySound(141);											end;										setData(oldX, oldY, whatToBlank);										Draw1(oldX, oldY);										Draw1(newX, newY);										if (num = 132) or ((num >= 900) and (num <= 952)) then											begin		{FINDTOCHANGE}												CoolPortals(oldX, oldY, newX, newY, myDir, num);											end										else											whatToBlank := 129;										if canScroll(myDir) then											begin												case myDir of													kUp: 														moveUp;													kRight: 														moveRight;													kDown: 														moveDown;													kLeft: 														moveLeft;												end;											end										else											RedrawBoard;									end;	{WOAH THIS IS IT BABAY}							end;					end;			end		else			begin				num := GetData(newX, newY);				if ((num >= 300) and (num <= 305)) and SpaceDown then					GetMurphyObj.ExplodeTWO(oldX, oldY)				else if num = 850 then					begin						case myDir of							kLeft: 								SetData(oldX, oldY, 195);							kUp: 								SetData(oldX, oldY, 199);							kRight: 								SetData(oldX, oldY, 194);							kDown: 								SetData(oldX, oldY, 200);						end;						DrawOne(oldX, oldY);						for count := 350 to 357 do							begin								SetData(newX, newY, count);								DrawOne(newX, newY);							end;						SetData(newX, newY, 129);						DrawOne(newX, newY);						GotInfotron;					end				else if num = 135 then					begin						case myDir of							kLeft: 								SetData(oldX, oldY, 195);							kUp: 								SetData(oldX, oldY, 199);							kRight: 								SetData(oldX, oldY, 194);							kDown: 								SetData(oldX, oldY, 200);						end;						DrawOne(oldX, oldY);						for count := 400 to 406 do							begin								SetData(newX, newY, count);								DrawOne(newX, newY);							end;						SetData(newX, newY, 129);						DrawOne(newX, newY);						GotRedDisk;					end				else if num = 128 then					begin						case myDir of							kLeft: 								SetData(oldX, oldY, 195);							kUp: 								SetData(oldX, oldY, 199);							kRight: 								SetData(oldX, oldY, 194);							kDown: 								SetData(oldX, oldY, 200);						end;						DrawOne(oldX, oldY);						for count := 450 to 456 do							begin								SetData(newX, newY, count);								DrawOne(newX, newY);							end;						SetData(newX, newY, 129);						DrawOne(newX, newY);					end;			end;		gMurphy.LastMove := tickCount;	end;	procedure HandlePlaying;		var			count: integer;			obppassdaw: CChore;			UNINITIALIZED_SO_THERE: rect;			dumbVar: longint;			oldX, oldY, newX, newY, myDir, cx, cy: integer;			myExplChore: CExplChore;			myWaitChore: CWaitTimeChore;			myAnim: AnimArray;			mx, my: integer;			md: integer;			dorkl: longint;			listInd: integer;			startTick, endTick: longint;	begin		startTick := tickCount;		SmoothMusic;{During Play, execute ALL chores}		for count := 1 to tbrLen do			if toBeRidded[count] <> nil then				begin					listInd := toBeRidded[count].listindex;					infoUrgents[listind] := infoUrgents[iuLen];{infoUrgents[iuLen] := nil;}					infoUrgents[listind].listindex := listind;					iuLen := iuLen - 1;					DisposeHandle(Handle(toBeRidded[count]));					toBeRidded[count] := nil;				end;		tbrLen := 0;		for count := 1 to tbaLen do			if toBeAdded[count] <> nil then				begin					iuLen := iuLen + 1;					infoUrgents[iuLen] := toBeAdded[count];					infoUrgents[iuLen].listindex := iuLen;					toBeAdded[count] := nil;				end;		tbaLen := 0;		for count := 1 to iuLen do			if infoUrgents[count] <> nil then				infoUrgents[count].perform(dorkl);		if iulen > 0 then			RedrawBoard;{What keys are down?}		GetKeys(myKeys);{Test to see if the capslock key is in the paused position}		if (myKeys[57] = pauseKeyState) then			begin				gameState := gameState + [isPaused];				ShowCursor;				ContSoundStop(musicRefNum);				musicRefNum := -1;{    if (hasMusic in gameState) and ChanUsed(1) then}{    ChanStop(1);}				HaltSounds;				PlaySound(sPause);				stopTime;				ShowMenuBar(gMainWind);			end		else if (not (freezeMurphy in GameState)) and (not gAARDVARK_PLATYPUSS_WOMBAT) then			begin				if lastWasPortal then					begin						myKeys[gUpKey] := myGoUp;{myOldKeys[gUpKey];}						myKeys[gLeftKey] := myGoLeft;						myKeys[gRightKey] := myGoRight;						myKeys[gDownKey] := myGoDown;						GetLoc(oldX, oldY);						Draw1(oldX - 1, oldY);						Draw1(oldX + 1, oldY);						Draw1(oldX, oldY - 1);						Draw1(oldX, oldY + 1);						lastWasPortal := FALSE;					end;				if myKeys[gUpKey] then					myDir := kUp				else if myKeys[gRightKey] then					myDir := kRight				else if myKeys[gDownKey] then					myDir := kDown				else if myKeys[gLeftKey] then					myDir := kLeft;				if myKeys[gUpKey] or myKeys[gRightKey] or myKeys[gDownKey] or myKeys[gLeftKey] then					begin						GetLoc(oldX, oldY);						newX := LocFromDir(oldX, oldY, myDir).h;						newY := LocFromDir(oldX, oldY, myDir).v;						MurphyMove(oldX, oldY, newX, newY, myDir, myKeys[gSpecKey]);						spaceBarWasDown := FALSE;						diskDropSndPlayed := FALSE;					end;				if GetName = 'Q42QaardvarkQ' then	{Majik Murphyª}					begin						if myKeys[34] then							myDir := kUp						else if myKeys[37] then							myDir := kRight						else if myKeys[46] then							myDir := kDown						else if myKeys[38] then							myDir := kLeft;						if myKeys[34] or myKeys[38] or myKeys[37] or myKeys[46] then							begin								GetLoc(oldX, oldY);								newX := LocFromDir(oldX, oldY, myDir).h;								newY := LocFromDir(oldX, oldY, myDir).v;								spaceBarWasDown := FALSE;								diskDropSndPlayed := FALSE;								lastMoved := TICKCOUNT;								SetData(oldX, oldY, whatToBlank);								Draw1(oldX, oldY);								whatToBlank := GetData(newX, newY);								SetData(newX, newY, 198);								Draw1(newX, newY);								SetLoc(newX, newY);								if canScroll(myDir) then									case myDir of										kUp: 											moveUp;										kRight: 											moveRight;										kDown: 											moveDown;										kLeft: 											moveLeft;									end								else									RedrawBoard;							end;					end;				if myKeys[53] then		{the esc key}					begin						GetLoc(oldX, oldY);						GetMurphyObj.Explode(oldX, oldY);					end;				if (not spaceBarWasDown) and myKeys[gSpecKey] then					begin		{the space bar key just went down}						whenWentDown := tickCount;						spaceBarWasDown := TRUE;		{yup, it's down.}						diskDropSndPlayed := FALSE;					end				else if spaceBarWasDown and not myKeys[gSpecKey] then					begin						spaceBarWasDown := FALSE;		{not any more!}{check to see if I should drop a bomb}						if tickCount - whenWentDown > (3 * 30) then							if UseRedDisk then								begin		{plant a red bomb there}									whatToBlank := 1105;		{when murphy moves, show the red disk}									GetLoc(oldX, oldY);									for count := 600 to 609 do										myAnim[count - 599] := count;									myAnim[11] := 129;									new(myExplChore);									myExplChore.IExplChore(oldX, oldY, myAnim, 11);									new(myWaitChore);									myWaitChore.IWaitTimeChore(myExplChore, 2);									FudAdd(myWaitChore);								end;					end;				if myKeys[gSpecKey] and spaceBarWasDown then					begin						if (tickCount - whenWentDown > (3 * 30)) and not diskDropSndPlayed then							if gMurphy.NumBombs > 0 then								begin									PlaySound(134);									diskDropSndPlayed := TRUE;								end;					end;			end;{FINDME}{THE STUFF FROM HERE ON COULD CAUSE PROBLEMS SINCE IT IS OUTSIDE OF THE IF THAT CHECKS FOR}{PAUSE KEY.}		if not (isPaused in gameState) then			begin{    myOldKeys := myKeys;}				if not (freezeMurphy in gameState) then					if tickCount - gMurphy.LastMove > (15) then						begin							GetLoc(mx, my);							md := GetData(mx, my);							if (md <> 198) and not isSleeping then								begin									SetData(mx, my, 198);									DrawOne(mx, my);									gMurphy.LastMove := tickCount;{new stuff}									gPhase := kMed;									gFromMed := kBig;								end;						end;				if isSleeping and not (freezeMurphy in gameState) then					begin						if ((sleepPhase <> 144) and (sleepPhase <> 141)) then							begin								if (scratchInteger = 0) then									begin										sleepPhase := sleepPhase + 1;										if sleepPhase > 511 then											begin												sleepPhase := 142;												scratchLongint := tickCount;												scratchInteger := 1;											end										else											begin												GetLoc(mx, my);												SetData(mx, my, sleepPhase);												DrawOne(mx, my);											end;									end								else if (scratchInteger = 1) and (tickCount - scratchLongint > (2 * 60)) then									begin{    sleepPhase := sleepPhase + 1;}										if (sleepPhase = 142) and (lastFacingLR = kLeft) then											sleepPhase := 139;										GetLoc(mx, my);										SetData(mx, my, sleepPhase);										DrawOne(mx, my);		{draw FOUR!... UNO!}										scratchLongint := tickCount;										scratchInteger := 2;									end								else if (scratchInteger = 2) and (tickCount - scratchLongint > (2 * 60)) then									begin										sleepPhase := sleepPhase + 1;										GetLoc(mx, my);										SetData(mx, my, sleepPhase);										DrawOne(mx, my);										scratchLongint := tickCount;										scratchInteger := 3;									end								else if (scratchInteger = 3) and (tickCount - scratchLongint > 25) then									begin										sleepPhase := sleepPhase + 1;										GetLoc(mx, my);										SetData(mx, my, sleepPhase);										DrawOne(mx, my);{scratchLongint := tickCount;}{scratchInteger := 3;}									end;							end;					end				else if tickCount - lastMoved > (20 * 60) then					begin						sleepPhase := 500;						isSleeping := TRUE;						scratchInteger := 0;					end;			end;		endTick := tickCount;		if (endTick - startTick) < kTicksBetween then			while (tickCount - startTick) < kTicksBetween do				;	end;	var		cntr: integer;		e: boolean;		c: integer;begin	HandlePlaying;	if shouldKillChores then		begin			DoKillChores;			ShowMenuBar(gMainWind);			ContSoundStop(musicRefNum);			musicRefNum := -1;			HaltSounds;{    if (hasMusic in gameState) then}{    for cntr := 1 to 4 do}{    ChanStop(cntr);}		end;	DrawTBoxes(FALSE);end;