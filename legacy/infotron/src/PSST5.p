unit PSST;{PECK SOFTWARE SOUND TOOL}{Written By David Peck}{PeckSoftware@his.com , 95DPECK@vax.mbhs.edu}{1993 All Rights Reserved.}{DESCRIPTION:}{The Peck Software Sound Tool allows up to 4 channels of background sound to be played}{at once. To start the sound tool, call}{INITALIZATION/SOUND EFFECTS:}{SoundsInit(true) for background sounds, and SoundsInit(false) for foreground sounds.}{To play a sound effect, call PlaySound(id) where id is the resource id of your sound.}{If you have the sound in memory, call PlaySoundHand(soundHand).}{PlaySound assumes that the sound has a synthesizer specified.}{When you are done with the sound unit, call SoundsClose.}{MUSIC NOTES:}{The Peck Software Sound Tool (PSST) allows you to specify musical notes to be played.}{This can be accomplished directly, by calling PlayMusicNote(id,note) where id is the}{sound resource id, and note is of type PSSTNote, declared below. If you already have}{the sound in memory, call PlayMusicNoteHand(soundHand,note).}{PSST attempts to keep sound effects in the upper four channels, and music in the lower four.}{However, sound effects take priority over music, so if four sound effects are in the queue,}{the music will be overriden temporarily. Also, all sounds for musical notes must be sampled}{at middle C.}{MUSIC SCORES:}{PSST defines a resource type, 탎ik, which actually defines an entire musical score. A}{탎ik resource can be played by calling PlayScore(id), where id is the resource id of your}{musical score. (탎ik resources can be generated by the 탒sic maker, also written by}{Peck Software.) PlayScore simply calls a series of PlayMusicNote commands, so sound}{effects will still have precedence over music.}{STOPING SOUNDS:}{PSST provides xxxxx methods for stopping a sound: One, you can call SoundStop, which}{stops all sounds. Two, you can call ScoreStop, which stops the musical score. Three,}{you can call ChanStop(chanNum) to stop the sound being generated by a particular channel.}{OTHER PSST ROUTINES:}{In addition to the main routines for sound effects and music, PSST also offers the following:}{FreeChans   -  a function which returns TRUE if there is at least one free channel.}{ChanUsed(chanNum) - a function which returns TRUE if channel chanNum is being used.}{SoundState(onOrOff) - PSST will play no sounds if onOrOff is FALSE.}{MasterVol(vol) - No sound will be louder than this volume.}{IMPORTANT:}{If you are using music scores, make sure you call MusicUpdate;}{every time through your event loop.}interface	uses		sound;			{use Apple's sound file header}	const		MusicScoreRes = '탎ik';{Define note durations}		quarter = 1;		half = 2;		whole = 4;		eighth = 0.5;		sixteenth = 0.25;		quarterDot = 1.5;		halfDot = 3;		wholeDot = 6;		eighthDot = 0.75;		sixteenthDot = 0.375;	type		PSSTNote = record				NoteName: integer;				octaveNum: integer;		{Octave}				noteAmp: integer;		{The amplitude (volume) of the note - 1..255}				noteSndRef: integer;		{The actual sound's refrence id which the note plays}				notePlaying: boolean;				noteDuration: integer;				noteSndHand: handle;				noteSndId: integer;			end;		Str2 = packed array[0..2] of char;		Str16 = packed array[0..16] of char;		SixteenthInfo = record			{A sixteenth quantization of the sound track}				hasNote: boolean;		{TRUE if a new note should be played}				noteOver: boolean;	{TRUE if there is a note, whether new or otherwise, covering this area.}										{THIS INCLUDES RESTS}				isRest: boolean;		{Both hasNote and isRest should be TRUE if a rest is to be played.}				insName: integer;		{The instrument sound data, an integer referring to the soundHndls array.}				oct: integer;				{the octave.}				vol: integer;				{the volume of the note. Happens to be in SMF}				duration: real;			{the duration}				selNoter: integer;		{the selNote}				noteDuration: longint;	{the duration, saved in half miliseconds. in SMF.}				noteName: integer;		{the actual value for the note name, in SMF}			end;		TrackDataPtr = ^TrackData;		TrackData = array[1..3200] of SixteenthInfo;			{=200 MEASURES of music in 4/4 time}		TrackArray = array[1..4] of TrackDataPtr;		TOneStrArray = array[1..7] of Str16;		TOneSoundArray = array[1..21] of Handle;		TOneIntArray = array[1..21] of integer;		qmh = ^qmp;		qmp = ^quantizedMusic;		quantizedMusic = record				music: TrackArray;				soundNames: TOneIntArray;	{the res ids of the sounds}				soundHndls: TOneSoundArray;	{twenty one handles to each of the seven sounds, with all octaves (c4,c5,etc.) in mem!}				soundNumUsed: TOneIntArray;		{How many times each of the sounds is used in the music}				tempo: integer;		{the music tempo}				endPoint: longint;				loopBegin: longint;				currentPoint: longint;			end;{Now that everything else has been declared, let's define the data structures to hold}{The four sound channels, and other info about them.}		ofpn = array[1..4] of PSSTNote;		ofha = array[1..4] of Handle;		PSSTSndType = (effect, music);		PSSTChans = array[1..4] of SndChannelPtr;		PSSTSnds = array[1..4] of Handle;		PSSTTypes = array[1..4] of PSSTSndType;		PSSTUsage = array[1..4] of boolean;		PSSTData = record				{The actual data which PSST uses.}				musicTempo: integer;				chans: PSSTChans;			{The channels where sound is channeled thru}				snds: PSSTSnds;				{The actual sounds corresponding to the chans}				types: PSSTTypes;			{Are the channels snd effects or music?}				usage: PSSTUsage;			{Which channels are being used?}				musicPlaying: boolean;		{TRUE if there is music playing}				qmhLoaded: boolean;			{TRUE if musicScore field actually points to a valid Quantized Music Score}				soundsOn: boolean;			{TRUE if PSST should play sounds.}				mastVol: integer;				{The master volume; nothing is louder than this.}				musicScore: qmh;			end;		PDPtr = ^PSSTData;		PDH = ^PDPtr;{Now it is time for procedure/function prototypes!}{Sound Effects/Initalization}	procedure SoundsInit (hasAsync: boolean);	procedure PlaySound (id: integer);	procedure PlaySoundHand (hand: handle);	procedure SoundsClose;{Musical Notes}	procedure PlayMusicNote (id: integer;									name: str255;									oct, vol: integer;									duration: real);	procedure PlayMNHand (hand: handle;									name: str255;									oct, vol: integer;									duration: real);	procedure MakeNote (var note: PSSTNote;									name: str255;									oct, vol: integer;									duration: real);	procedure SetMusicTempo (tempo: integer);{Musical Scores}	procedure PlayScore (id: integer); {Play the 탎ik resource with a given id, in the background.}{Stopping Sounds}	procedure SoundStop;	procedure ScoreStop;	procedure ChanStop (chanNum: integer);{Misc. Routines}	function FreeChans: boolean;	function ChanUsed (chanNum: integer): boolean;	procedure SoundState (state: boolean);	procedure MasterVol (vol: integer);	procedure PauseChan (chan: integer);	function NewMusic: qmh;			{Create a new musical score, and return the initialized QuantizedMusicHandle}	procedure MusicForeground;		{Play the current QMH in the foreground}{Idle Routine}	procedure UpdateSounds;			{call this everytime thru event loop...}{Don't call these!}	procedure StartAsyncPlayNote (h: handle;									n: PSSTNote);	procedure DoAsyncPlayNote (h: handle;									num: integer;									n: PSSTNote);	procedure PlayFourNotes (h: ofha;									n: ofpn);implementation{Private Variables}	var		dat: pdh;		{All the data for PSST}		async: boolean;	{TRUE if user is doing async sounds}		soundsOn: boolean;{Private Routines}{The following routine, SoundCallback, will get called at interrupt time.}{Therefore, it is possible (and likely) that the A5 world will not be the world}{of the application using PSST. If debugging is on, this can cause some serious}{crashes. Therefore, for SoundCallback, debugging etc... must be turned off!}{$PUSH}{$D-}{$N-}{$V-}{$R-}	procedure SoundCallback (chan: SndChannelPtr;									cmd: SndCommand);		var			dt: pdh;			num: integer;	begin		dt := pdh(cmd.param2);		num := cmd.param1;		dt^^.usage[num] := false;		dt^^.snds[num] := nil;{DisposHandle(dt^^.snds[num]);}	end;{$POP}	procedure Secure (var d: pdh);	begin		MoveHHi(handle(d));		HLock(handle(d));	end;	procedure Unsecure (var d: pdh);	begin		HUnlock(handle(d));	end;	function AFreeChan: integer;{precondition: there is at least one free channel}		var			cnt: integer;	begin		cnt := 1;		while dat^^.usage[cnt] do			cnt := cnt + 1;		AFreeChan := cnt;	end;	function CanStopChan: boolean;{precondition: there are no free channels}	begin		CanStopChan := (dat^^.types[1] = music) or (dat^^.types[2] = music) or (dat^^.types[3] = music) or (dat^^.types[4] = music);	end;	function StopMusicChan: integer;{precondition: at least one channel has music}		var			cnt: integer;	begin		cnt := 4;		while dat^^.types[cnt] <> music do			cnt := cnt - 1;		StopMusicChan := cnt;	end;	procedure DoAsyncPlay (h: handle;									num: integer);		var			cmod: SndCommand;			err: OSErr;	begin		with cmod do			begin				cmd := CallBackCmd;				param1 := num;				param2 := longint(dat);			end;{MoveHHi(h);}{    HLock(h);}		err := SndPlay(dat^^.chans[num], h, true);		dat^^.usage[num] := true;		dat^^.types[num] := effect;		dat^^.snds[num] := h;		err := SndDoCommand(dat^^.chans[num], cmod, FALSE);{    HUnlock(h);}	end;	procedure StartAsyncPlay (h: handle);		var			whichChan: integer;			doit: boolean;	begin		doit := true;		if FreeChans then			whichChan := AFreeChan		else if CanStopChan then			whichChan := StopMusicChan		else			doit := false;		if doit then			DoAsyncPlay(h, whichChan);	end;	procedure PlayFourNotes (h: ofha;									n: ofpn);		var			cbackcmd, ampcmde, freqcmde, sndcmde: array[1..4] of SndCommand;			err: OSErr;			myP2: fixed;			c: integer;			d: PSSTData;	begin		d := dat^^;		for c := 1 to 4 do			begin				cbackcmd[c].cmd := callBackCmd;				cbackcmd[c].param1 := c;				cbackcmd[c].param2 := longint(dat);				ampcmde[c].cmd := ampCmd;				ampcmde[c].param1 := n[c].noteAmp;				ampcmde[c].param2 := 0;				freqcmde[c].cmd := freqDurationCmd;				freqcmde[c].param1 := n[c].noteduration;				freqcmde[c].param2 := n[c].noteName;				sndcmde[c].cmd := soundCmd;				sndcmde[c].param1 := 0;				sndcmde[c].param2 := longint(h[c]^) + 20;				d.usage[c] := true;				d.types[c] := music;{    d.snds[c] := h[c];}			end;		for c := 1 to 4 do			if n[c].noteAmp > 0 then				ChanStop(c);		for c := 1 to 4 do			if n[c].noteAmp > 0 then				err := SndDoCommand(d.chans[c], sndcmde[c], false);		for c := 1 to 4 do			if n[c].noteAmp > 0 then				err := SndDoCommand(d.chans[c], ampcmde[c], false);		for c := 1 to 4 do			if n[c].noteAmp > 0 then				begin					err := SndDoCommand(d.chans[c], freqcmde[c], false);					err := SndDoCommand(d.chans[c], cbackcmd[c], false);				end;	end;	procedure DoAsyncPlayNote (h: handle;									num: integer;									n: PSSTNote);		var			cmod, cmed, ched: SndCommand;			cbackcmd, ampcmde, freqcmde, sndcmde: SndCommand;			err: OSErr;			myP2: fixed;	begin{    MoveHHi(h);}{    HLock(h);}		cbackcmd.cmd := callBackCmd;		cbackcmd.param1 := num;		cbackcmd.param2 := longint(dat);		ampcmde.cmd := ampCmd;		ampcmde.param1 := n.noteAmp;		ampcmde.param2 := 0;		freqcmde.cmd := freqDurationCmd;		freqcmde.param1 := n.noteduration;		freqcmde.param2 := n.noteName;		sndcmde.cmd := soundCmd;		sndcmde.param1 := 0;		sndcmde.param2 := longint(h^) + 20;		dat^^.usage[num] := true;		dat^^.types[num] := music;		dat^^.snds[num] := h;		err := SndDoCommand(dat^^.chans[num], sndcmde, false);		err := SndDoCommand(dat^^.chans[num], ampcmde, false);		err := SndDoCommand(dat^^.chans[num], freqcmde, false);		err := SndDoCommand(dat^^.chans[num], cbackcmd, false);{    err := SndPlay(dat^^.chans[num], h, true);}{    HUnlock(h);}	end;	procedure StartAsyncPlayNote (h: handle;									n: PSSTNote);		var			whichChan: integer;			doit: boolean;	begin		doit := true;		if FreeChans then			whichChan := AFreeChan		else if CanStopChan then			whichChan := StopMusicChan		else			doit := false;		if doit then			DoAsyncPlayNote(h, whichChan, n);	end;	procedure ___________;		{This is just here for command-clicking window title bar}	begin	end;{Sound Effects/Initalization}	function NewMusic: qmh;			{Create a new musical score, and return the initialized QuantizedMusicHandle}		var			c: integer;			cn: integer;	begin		dat^^.musicScore := qmh(NewHandleClear(sizeOf(QuantizedMusic)));		{Everything is 0, for convenience}		cn := 0;		if dat^^.musicScore <> nil then			begin				MoveHHi(handle(dat^^.musicScore));				HLock(handle(dat^^.musicScore));				for c := 1 to 4 do					begin						dat^^.musicScore^^.music[c] := nil;						dat^^.musicScore^^.music[c] := TrackDataPtr(NewPtrClear(sizeOf(TrackData)));		{create a new track!}						if dat^^.musicScore^^.music[c] <> nil then							begin								cn := cn + 1;							end;					end;				if cn = 4 then					begin						dat^^.qmhLoaded := true;		{SUCCESS!}						dat^^.musicScore^^.tempo := 120;		{a standard tempo}					end				else					begin						SysBeep(10);						SysBeep(10);						showtext;						writeln('MEMORY ERROR #-2250', cn : 1);						for c := 1 to 4 do							if dat^^.musicScore^^.music[c] <> nil then								DisposePtr(ptr(dat^^.musicScore^^.music[c]));						HUnlock(handle(dat^^.musicScore));						DisposeHandle(handle(dat^^.musicScore));					end;			end		else			begin				showText;				writeln('MO0222');				SysBeep(10);			end;		NewMusic := dat^^.musicScore;	end;	procedure MusicForeground;		{Play the current QMH}	begin	end;	procedure SoundsInit (hasAsync: boolean);		var			cnt: integer;			err: OSErr;			val: real;	begin		async := hasAsync;		soundsOn := true;		if hasAsync then			begin				dat := pdh(NewHandleClear(sizeOf(PSSTData)));				MoveHHi(handle(dat));			{secure it!}				HLock(handle(dat));				for cnt := 1 to 4 do					begin						err := SndNewChannel(dat^^.chans[cnt], sampledSynth, initMono, @SoundCallback);						dat^^.usage[cnt] := false;					end;				dat^^.qmhLoaded := false;				dat^^.musicPlaying := false;				dat^^.soundsOn := true;				dat^^.mastVol := 7;				dat^^.musicScore := nil;				dat^^.musicTempo := 120;			{120 beats/minute is standard}			end;	end;	procedure PlaySound (id: integer);		var			err: OSErr;			sndHand: handle;	begin		if soundsOn then			begin				sndHand := GetResource('snd ', id);				if not async then					err := SndPlay(nil, sndHand, false)				else					StartAsyncPlay(sndHand);			end;	end;	procedure PlaySoundHand (hand: handle);		var			err: OSErr;	begin		if not async then			err := SndPlay(nil, hand, false)		else			StartAsyncPlay(hand);	end;	procedure SoundsClose;		var			cnt: integer;			err: OSErr;	begin		if async then			begin				SoundStop;			{Stop all sounds}				if dat <> nil then					begin						for cnt := 1 to 4 do							begin								if dat^^.chans[cnt] <> nil then									err := SndDisposeChannel(dat^^.chans[cnt], true);								dat^^.snds[cnt] := nil;							end;{    if dat^^.musicScore <> nil then}{DisposPtr(ptr(dat^^.musicScore));}						HUnlock(handle(dat));						DisposHandle(handle(dat));					end;			end;	end;{Musical Notes}	procedure SetMusicTempo (tempo: integer);	begin		dat^^.musicTempo := tempo;	end;	procedure PlayMusicNote (id: integer;									name: str255;									oct, vol: integer;									duration: real);		var			hand: handle;			mFreq: longint;			note: PSSTNote;	begin		MakeNote(note, name, oct, vol, duration);		if async then			begin				hand := GetResource('snd ', id);				StartAsyncPlayNote(hand, note);			end;	end;	procedure PlayMNHand (hand: handle;									name: str255;									oct, vol: integer;									duration: real);		var			note: PSSTNote;	begin		MakeNote(note, name, oct, vol, duration);		if async then			StartAsyncPlayNote(hand, note);	end;	procedure MakeNote (var note: PSSTNote;									name: str255;									oct, vol: integer;									duration: real);		procedure Lower (var n: str255);			var				cnt: integer;		begin			for cnt := 1 to length(n) do				if (n[cnt] >= 'A') and (n[cnt] <= 'Z') then					n[cnt] := char(ord(n[cnt]) + 32);		end;		function vfn (n: str255): integer;		{vfn - Value From Name}		begin			if n = 'c' then				vfn := 0			else if (n = 'c+') or (n = 'd-') then				vfn := 1			else if n = 'd' then				vfn := 2			else if (n = 'd+') or (n = 'e-') then				vfn := 3			else if n = 'e' then				vfn := 4			else if n = 'f' then				vfn := 5			else if (n = 'f+') or (n = 'g-') then				vfn := 6			else if n = 'g' then				vfn := 7			else if (n = 'g+') or (n = 'a-') then				vfn := 8			else if n = 'a' then				vfn := 9			else if (n = 'a+') or (n = 'b-') then				vfn := 10			else if n = 'b' then				vfn := 11;		end;	begin		with note do			begin				octaveNum := oct;			{Middle octave=4!!!}				noteAmp := vol;				noteSndHand := nil;		{These get set later. The note simply specifices volume, etc...}				noteSndId := 0;				Lower(name);				noteName := 60 + (12 * (oct - 4)) + vfn(name);{Extract out the note 'name' in snd manager format}													{In this format, 60=middle C, and each 12 numbers}													{is an octave.}				noteDuration := trunc(duration * (60 / dat^^.musicTempo) * 2000);			end;	end;{Musical Scores}	procedure PlayScore (id: integer);	begin		if async then			begin				if dat^^.musicPlaying then					ScoreStop;			{Stop the previous musical score}				dat^^.musicScore := qmh(GetResource(MusicScoreRes, id));				if resError = noErr then					begin						dat^^.musicPlaying := true;						dat^^.qmhLoaded := true;					end;				MoveHHi(handle(dat^^.musicScore));				HLock(handle(dat^^.musicScore));			end;	end;	procedure UpdateSounds;			{Do general memory housekeeping}		var			cnt: integer;	begin		if async then			begin				for cnt := 1 to 4 do					if (dat^^.snds[cnt] <> nil) and not dat^^.usage[cnt] then						DisposHandle(dat^^.snds[cnt]);				if dat^^.musicPlaying then					begin					end;			end;	end;	procedure UnloadScore;		var			c: integer;	begin		if dat^^.musicScore <> nil then			begin				ScoreStop;				for c := 1 to 4 do					if dat^^.musicScore^^.music[c] <> nil then						DisposePtr(ptr(dat^^.musicScore^^.music[c]));				for c := 1 to 21 do					if dat^^.musicScore^^.soundHndls[c] <> nil then						ReleaseResource(dat^^.musicScore^^.soundHndls[c]);				HUnlock(handle(dat^^.musicScore));				DisposeHandle(handle(dat^^.musicScore));				dat^^.musicScore := nil;				dat^^.qmhLoaded := false;			end;	end;{Stopping Sounds}	procedure SoundStop;		var			cnt: integer;	begin		if async then			begin				for cnt := 1 to 4 do					ChanStop(cnt);{if dat^^.qmhLoaded then}{UnloadScore;}			end;	end;	procedure ScoreStop;		var			err: OSErr;			cnt: integer;			qcmd: SndCommand;	begin		if async then			if dat^^.musicPlaying and (dat^^.musicScore <> nil) then				begin					for cnt := 1 to 4 do						if (dat^^.types[cnt] = music) and (dat^^.snds[cnt] <> nil) then							ChanStop(cnt);					dat^^.musicPlaying := false;				end;	end;	procedure ChanStop (chanNum: integer);		var			err: OSErr;			qcmd: SndCommand;	begin		if async then			if dat^^.usage[chanNum] then				begin					qcmd.cmd := quietCmd;					qcmd.param1 := 0;					qcmd.param2 := 0;					err := SndDoImmediate(dat^^.chans[chanNum], qcmd);					dat^^.usage[chanNum] := false;				end;	end;{Misc. Routines}	procedure PauseChan (chan: integer);		var			mine: boolean;			event: EventRecord;	begin		repeat			mine := GetNextEvent(everyEvent, event);			SystemTask;			UpdateSounds;		until not ChanUsed(chan);	end;	function FreeChans: boolean;	begin		FreeChans := not (dat^^.usage[1] and dat^^.usage[2] and dat^^.usage[3] and dat^^.usage[4]);	end;	function ChanUsed (chanNum: integer): boolean;{precondition: chanNum 1..4}	begin		ChanUsed := dat^^.usage[chanNum];	end;	procedure SoundState (state: boolean);	begin		if async then			soundsOn := state;	end;	procedure MasterVol (vol: integer);	begin		if (vol >= 0) and (vol <= 7) then			begin				SetSoundVol(vol);				if async then					dat^^.mastVol := vol;			end;	end;end.		{That was quick. :)}